-- Exercise 1 Simple SQL Queries
-- Problem 1
SELECT LASTNAME,FIRSTNME,BIRTHDATE,SALARY
FROM DB2INST1.EMPLOYEE
WHERE SALARY >50000
ORDER BY SALARY DESC;
-- Problem 2
SELECT LASTNAME,FIRSTNME,WORKDEPT
FROM DB2INST1.EMPLOYEE
ORDER BY WORKDEPT DESC,LASTNAME DESC;
-- Problem 3
SELECT EDLEVEL
FROM DB2INST1.EMPLOYEE
GROUP BY EDLEVEL
ORDER BY EDLEVEL DESC;
-- Problem 4
SELECT EMPNO,PROJNO
FROM DB2INST1.EMPPROJACT
WHERE EMPNO <='00100'
GROUP BY EMPNO, PROJNO
ORDER BY EMPNO;
-- Problem 5
SELECT LASTNAME,SALARY,BONUS
FROM DB2INST1.EMPLOYEE
WHERE SEX LIKE 'M';
-- Problem 6
SELECT LASTNAME,SALARY,COMM
FROM DB2INST1.EMPLOYEE
WHERE SALARY >= 20000 AND YEAR(HIREDATE) > 1979;
-- Problem 7
SELECT LASTNAME,SALARY,BONUS,COMM
FROM DB2INST1.EMPLOYEE
WHERE (SALARY >= 22000 AND BONUS = 400) OR (BONUS = 500 AND COMM <=1900)
ORDER BY LASTNAME;
-- Problem 8
SELECT LASTNAME,BONUS,COMM
FROM DB2INST1.EMPLOYEE
WHERE SALARY >=22000 AND (BONUS = 400 OR BONUS = 500) AND COMM <=1900
ORDER BY LASTNAME;
-- Problem 9
SELECT PROJNO,ACTNO,EMSTDATE,EMENDATE
FROM DB2INST1.EMPPROJACT
WHERE PROJNO LIKE 'AD%' AND (ACTNO = 10 OR ACTNO = 80 OR ACTNO =180)
ORDER BY PROJNO;
-- Problem 10
SELECT MGRNO,DEPTNO
FROM DB2INST1.DEPARTMENT
WHERE MGRNO IS NOT NULL
ORDER BY MGRNO;
-- Problem 11
SELECT EMPNO,LASTNAME,SALARY,BONUS
FROM DB2INST1.EMPLOYEE
WHERE BONUS >=800 AND BONUS <=1000
ORDER BY BONUS ASC,EMPNO ASC;
-- Problem 12
SELECT EMPNO,LASTNAME,SALARY,WORKDEPT
FROM DB2INST1.EMPLOYEE
WHERE WORKDEPT BETWEEN 'A00' AND 'C01'
ORDER BY LASTNAME,EMPNO;
-- Problem 13
SELECT *
FROM DB2INST1.PROJECT
WHERE PROJNAME LIKE '%SUPPORT%'
ORDER BY PROJNO;
-- Problem 14
SELECT *
FROM DB2INST1.DEPARTMENT
WHERE SUBSTR(DEPTNO,2,1) LIKE '1'
ORDER BY DEPTNO;
----- OR -----
SELECT *
FROM DB2INST1.DEPARTMENT
WHERE DEPTNO LIKE '_1_'
ORDER BY DEPTNO;
-- Problem 15
SELECT LASTNAME,FIRSTNME,MIDINIT,SALARY
FROM DB2INST1.EMPLOYEE
WHERE JOB NOT LIKE 'MANAGER%' AND JOB NOT LIKE 'PRES%'
ORDER BY SALARY DESC
LIMIT 5;

-- Exercise 2 Retrieving Data from Multiple Tables
-- Problem 1
SELECT e.LASTNAME,e.FIRSTNME,d.DEPTNAME AS DEPTNAME
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d
        ON e.WORKDEPT = d.DEPTNO
ORDER BY DEPTNAME,LASTNAME, FIRSTNME;
-- Problem 2
SELECT e.LASTNAME,e.FIRSTNME,e.JOB,d.DEPTNAME AS DEPTNAME
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d
        ON e.WORKDEPT = d.DEPTNO
WHERE d.DEPTNO BETWEEN 'A02' AND 'D22' AND e.JOB NOT LIKE 'MANAGER%'
ORDER BY DEPTNAME,JOB,LASTNAME, FIRSTNME;
-- Problem 3
SELECT d.DEPTNAME,e.LASTNAME,e.FIRSTNME
FROM DB2INST1.DEPARTMENT d
    JOIN DB2INST1.EMPLOYEE e
        ON d.MGRNO = e.EMPNO
ORDER BY DEPTNAME;
-- Problem 4
SELECT d.DEPTNAME,e.LASTNAME,e.FIRSTNME
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d
        ON d.DEPTNO = e.WORKDEPT
WHERE e.JOB LIKE 'MANAGER%'
ORDER By DEPTNAME;
-- Ans NO, BECAUSE THE MANAGER OF 'SPIFFY COMPUTER SERVICE DIV.' HAVE THE MAIN JOB IS PRES
-- BUT MAY BE HE IS ALSO THE MANAGER OF 'SPIFFY COMPUTER SERVICE DIV.'
-- Problem 5
SELECT DISTINCT p.PROJNO,p.PROJNAME,ep.ACTNO
FROM DB2INST1.PROJECT p
    JOIN DB2INST1.EMPPROJACT ep
        ON p.PROJNO = ep.PROJNO
WHERE p.PROJNO LIKE 'AD%'
ORDER BY PROJNO,ACTNO;
-- Problem 6
SELECT DISTINCT e.EMPNO,e.LASTNAME,ep.PROJNO
FROM DB2INST1.EMPPROJACT ep
    JOIN DB2INST1.EMPLOYEE e
        ON ep.EMPNO = e.EMPNO
WHERE ep.PROJNO LIKE 'AD3113'
ORDER BY EMPNO,PROJNO;
-- Problem 7 > CHANGE 1982 TO 2002
SELECT e.EMPNO,ep.PROJNO,ep.ACTNO,ep.EMSTDATE
    FROM DB2INST1.EMPPROJACT ep
        JOIN DB2INST1.EMPLOYEE e ON e.EMPNO = ep.EMPNO
        JOIN DB2INST1.PROJECT p on ep.PROJNO = p.PROJNO
WHERE ep.EMSTDATE LIKE '2002-10-01'
ORDER BY PROJNO,EMPNO,ACTNO;
-- Problem 8
SELECT e.WORKDEPT,e.LASTNAME,p.PROJNAME,ep.ACTNO
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.EMPPROJACT ep
        ON ep.EMPNO = e.EMPNO
    JOIN DB2INST1.PROJECT p
        ON p.PROJNO = ep.PROJNO
WHERE e.WORKDEPT LIKE 'A00'
ORDER BY PROJNAME,ACTNO;
-- Problem 9
SELECT DISTINCT e.WORKDEPT,e.LASTNAME,p.PROJNAME,ep.ACTNO
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.EMPPROJACT ep
        ON ep.EMPNO = e.EMPNO
    JOIN DB2INST1.PROJECT p
        ON p.PROJNO = ep.PROJNO
WHERE e.WORKDEPT BETWEEN 'A00' AND 'C01'
ORDER BY WORKDEPT,LASTNAME,ACTNO;
-- Problem 10 > CHANGE 1982 TO 2002
SELECT ACTNO,MGRNO,EMSTDATE,p.PROJNO,LASTNAME FROM DB2INST1.EMPPROJACT ep
JOIN DB2INST1.PROJECT p ON ep.PROJNO = p.PROJNO
JOIN DB2INST1.DEPARTMENT d ON p.DEPTNO = d.DEPTNO
JOIN DB2INST1.EMPLOYEE e ON ep.EMPNO = e.EMPNO
WHERE EMSTDATE >= '2002-10-15'
ORDER BY ACTNO,EMSTDATE;
-- Problem 10x > CHANGE 1982 TO 2002
SELECT ACTNO,MGRNO,em.LASTNAME AS MANAGER_LASTNAME,EMSTDATE,p.PROJNO,e.LASTNAME AS EMPLOYEE_LASTNAME FROM DB2INST1.EMPPROJACT ep
JOIN DB2INST1.PROJECT p ON ep.PROJNO = p.PROJNO
JOIN DB2INST1.DEPARTMENT d ON p.DEPTNO = d.DEPTNO
JOIN DB2INST1.EMPLOYEE e ON ep.EMPNO = e.EMPNO
JOIN DB2INST1.EMPLOYEE em ON d.MGRNO = em.EMPNO
WHERE EMSTDATE >= '2002-10-15'
ORDER BY ACTNO,EMSTDATE;
-- Problem 11
SELECT DEPTNO,
       em.LASTNAME AS MANAGER_LASTNAME,
       e.LASTNAME AS EMPLOYEE_LASTNAME,
       em.HIREDATE AS MANAGER_HIREDATE,
       e.HIREDATE AS EMPLOYEE_HIREDATE
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d
        ON d.DEPTNO = WORKDEPT
    JOIN DB2INST1.EMPLOYEE em
        ON d.MGRNO = em.EMPNO
WHERE e.HIREDATE < em.HIREDATE
  AND e.WORKDEPT LIKE 'A00'
ORDER BY e.LASTNAME;
-- Problem 11.x find the employee that older than manager
SELECT DEPTNO,
       em.LASTNAME AS MANAGER_LASTNAME,
       e.LASTNAME AS EMPLOYEE_LASTNAME,
       em.BIRTHDATE AS MANAGER_BIRTHDATE,
       e.BIRTHDATE AS EMPLOYEE_BIRTHDATE
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d
        ON d.DEPTNO = WORKDEPT
    JOIN DB2INST1.EMPLOYEE em
        ON d.MGRNO = em.EMPNO
WHERE e.BIRTHDATE < em.BIRTHDATE
ORDER BY DEPTNO,e.LASTNAME;
-- EXERCISE 3 Scalar Function Arithmetic
-- Problem 1 > CHANGE 20000 TO 40000
SELECT LASTNAME,
       SALARY,
       CAST(ROUND(SALARY*12*1.05,2) AS DECIMAL(12,2)) AS INC_Y_SALARY,
       CAST(ROUND(SALARY*1.05,2) AS DECIMAL(12,2)) AS INC_M_SALARY
FROM DB2INST1.EMPLOYEE e
WHERE (e.SALARY *1.05) <= 40000
ORDER BY INC_Y_SALARY;
-- Problem 2
SELECT LASTNAME,
       EDLEVEL,
       SALARY+1200 AS NEW_SALARY,
       CAST(BONUS/2 AS DECIMAL(8,2)) AS NEW_BONUS
FROM DB2INST1.EMPLOYEE
WHERE EDLEVEL BETWEEN 18 AND 20
ORDER BY EDLEVEL DESC,SALARY;
-- Problem 3 > CHANGE 20000 TO 40000
SELECT WORKDEPT,LASTNAME,SALARY,SALARY-1000 AS DECR_SALARY
FROM DB2INST1.EMPLOYEE
WHERE WORKDEPT LIKE 'D11'
  AND SALARY BETWEEN  0.8*40000 AND 1.2*40000
ORDER BY SALARY;
-- Problem 4 > CHANGE 10 % TO 5%
SELECT WORKDEPT,LASTNAME,(SALARY+COMM+BONUS) AS INCOME,SALARY FROM DB2INST1.EMPLOYEE
WHERE WORKDEPT LIKE 'D11'
   AND SALARY+COMM+BONUS > SALARY*1.05
ORDER BY SALARY;
-- Problem 5
SELECT DEPTNO,
       DEPTNAME,
       COALESCE(MGRNO,'UNKNOWN') AS MGRNO
FROM DB2INST1.DEPARTMENT
WHERE MGRNO is null;
-- Problem 6
SELECT PROJNO,
       COALESCE(MAJPROJ,'MAIN PROJECT') AS MAJOR_PROJECT
FROM DB2INST1.PROJECT
WHERE PROJNO LIKE 'MA%'
ORDER BY PROJNO;
-- Problem 7
SELECT EMPNO,
       LASTNAME,
       YEAR(HIREDATE - BIRTHDATE) AS AGE
FROM DB2INST1.EMPLOYEE
WHERE YEAR(HIREDATE - BIRTHDATE) < 25 AND YEAR(HIREDATE - BIRTHDATE) >= 0
ORDER BY AGE, EMPNO;
-- Problem 8
SELECT YEAR(PRSTDATE) AS YEAR,
       MONTH(PRSTDATE) AS MONTH,
       PROJNO
FROM DB2INST1.PROJECT
WHERE PRENDATE LIKE '1982-12-01'
ORDER BY PROJNO;
-- Problem 9
SELECT PROJNO,
       CAST(ROUND((DAYS(PRENDATE) - DAYS(PRSTDATE)) / 7.0,1) AS DECIMAL(20,1)) AS WEEKS
FROM DB2INST1.PROJECT
WHERE PROJNO LIKE 'MA%' AND (DAYS(PRENDATE) - DAYS(PRSTDATE)) / 7.0 > 0
ORDER BY PROJNO;
-- Problem 10
SELECT PROJNO,
       PRENDATE,
       DATE(PRSTDATE) + ROUND((DAYS(PRENDATE)-DAYS(PRSTDATE))*1.1,0) DAY
           AS MODIFY
FROM DB2INST1.PROJECT
WHERE PROJNO LIKE 'MA%'
ORDER BY PROJNO;
-- Problem 11
SELECT DAYS(DATE('2000-01-01'))-DAYS(DATE('1969-07-20')) AS DAYS
FROM SYSIBM.SYSDUMMY1
WHERE 1=1;

-- Exercise 4 Column Functions and Grouping
-- Problem 1
SELECT DEPTNO,
       SUM(SALARY) AS SUM_SALARY
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d ON e.WORKDEPT = d.DEPTNO
GROUP BY DEPTNO;
-- Problem 2
SELECT DEPTNO,
       COUNT(EMPNO) AS EMP_COUNT
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d ON e.WORKDEPT = d.DEPTNO
GROUP BY DEPTNO;
-- Problem 3
SELECT DEPTNO,
       COUNT(EMPNO) AS EMP_COUNT
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d ON e.WORKDEPT = d.DEPTNO
GROUP BY DEPTNO
HAVING COUNT(EMPNO) >3;
-- Problem 4
SELECT DEPTNO,
       COUNT(e.EMPNO) AS DES_COUNT
FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d ON e.WORKDEPT = d.DEPTNO
WHERE e.JOB LIKE 'DESIGNER%'
GROUP BY DEPTNO;
-- Problem 5
SELECT WORKDEPT,
       SEX,
       CAST(ROUND(AVG(SALARY),2) AS DECIMAL(20,2)) AS AVG_SALARY,
       CAST(ROUND(AVG(BONUS),2) AS DECIMAL(20,2)) AS AVG_BONUS,
       CAST(ROUND(AVG(COMM),2) AS DECIMAL(20,2)) AS AVG_COMM,
       COUNT(*) AS COUNT
FROM DB2INST1.EMPLOYEE
GROUP BY WORKDEPT, SEX
HAVING COUNT(*) >=2;
-- Problem 6
SELECT WORKDEPT,
       CAST(ROUND(AVG(BONUS),2) AS DECIMAL(20,2)) AS AVG_BONUS,
       CAST(ROUND(AVG(COMM),2) AS DECIMAL(20,2)) AS AVG_COMM
FROM DB2INST1.EMPLOYEE
GROUP BY WORKDEPT
HAVING ROUND(AVG(BONUS),2) > 500 AND ROUND(AVG(COMM),2) > 2000;
-- Exercise 5 Union
-- Problem 1
SELECT LASTNAME, FIRSTNME, 'BEFORE A RAISE' AS WHEN, SALARY FROM DB2INST1.EMPLOYEE
JOIN DB2INST1.DEPARTMENT ON WORKDEPT = DEPTNO
WHERE WORKDEPT LIKE 'D21' AND JOB NOT LIKE 'MANAGER%'
    UNION
SELECT LASTNAME, FIRSTNME, 'AFTER A RAISE' AS WHEN, SALARY*1.1 AS SALARY FROM DB2INST1.EMPLOYEE
JOIN DB2INST1.DEPARTMENT ON WORKDEPT = DEPTNO
WHERE WORKDEPT LIKE 'D21' AND JOB NOT LIKE 'MANAGER%'
ORDER BY LASTNAME,FIRSTNME,WHEN DESC;
-- Problem 2
SELECT DEPTNO,EMPNO,SALARY
FROM DB2INST1.EMPLOYEE
    JOIN DB2INST1.DEPARTMENT ON DEPTNO = WORKDEPT
WHERE DEPTNO LIKE 'A00'
UNION
SELECT null,null,SUM(SALARY) AS SALARY
FROM DB2INST1.EMPLOYEE
    JOIN DB2INST1.DEPARTMENT ON DEPTNO = WORKDEPT
WHERE DEPTNO LIKE 'A00';
-- Problem 3
SELECT DEPTNO,'DEPARTMENT' AS DEPARTMENT,DEPTNAME,1 AS SORT
FROM DB2INST1.DEPARTMENT
WHERE DEPTNO IN ('A00','B01','C01')
UNION ALL
    SELECT DEPTNO, PROJNO, PROJNAME,2 AS SORT
    FROM DB2INST1.PROJECT
    WHERE DEPTNO IN ('A00', 'B01', 'C01')
UNION ALL
    SELECT WORKDEPT, e.EMPNO, e.LASTNAME,3 AS SORT
    FROM DB2INST1.EMPLOYEE e
    WHERE WORKDEPT IN ('A00', 'B01', 'C01')
ORDER BY DEPTNO,SORT;
-- Problem 3.X Show only the department that have project
SELECT d.DEPTNO,'DEPARTMENT' AS DEPARTMENT,DEPTNAME,1 AS SORT
FROM DB2INST1.DEPARTMENT d
JOIN DB2INST1.PROJECT p ON d.DEPTNO = p.DEPTNO
WHERE d.DEPTNO IN ('A00','B01','C01')
GROUP BY d.DEPTNO, 'DEPARTMENT', DEPTNAME, 1
HAVING COUNT(PROJNO) > 0
UNION ALL
    SELECT p.DEPTNO, PROJNO, PROJNAME,2 AS SORT
    FROM DB2INST1.PROJECT p
    WHERE p.DEPTNO IN ('A00', 'B01', 'C01')
UNION ALL
    SELECT e.WORKDEPT, e.EMPNO, e.LASTNAME,3 AS SORT
    FROM DB2INST1.EMPLOYEE e
    JOIN DB2INST1.DEPARTMENT d on e.WORKDEPT = d.DEPTNO
    JOIN DB2INST1.PROJECT p ON d.DEPTNO = p.DEPTNO
    WHERE e.WORKDEPT IN ('A00', 'B01', 'C01')
    GROUP BY e.WORKDEPT, e.EMPNO, e.LASTNAME, 3
    HAVING COUNT(PROJNO) > 0
ORDER BY DEPTNO,SORT;
-- Problem 4
SELECT 'PROJECT' AS PROJECT ,p.PROJNO AS PROJNO,COUNT(DISTINCT  EMPNO) AS EMPLOYEES,PRSTDATE AS START,PRENDATE AS END,1 AS SORT
FROM DB2INST1.PROJECT p
    JOIN DB2INST1.EMPPROJACT em ON p.PROJNO = em.PROJNO
WHERE p.PROJNO LIKE 'IF%'
GROUP BY p.PROJNO, 'PROJECT', PRSTDATE, PRENDATE
UNION ALL
SELECT CONCAT('ACT ',em.ACTNO) AS PROJECT ,p.PROJNO AS PROJNO,EMPNO AS EMPLOYEES,EMSTDATE AS START,EMENDATE AS END,2 AS SORT
FROM DB2INST1.PROJECT p
    JOIN DB2INST1.EMPPROJACT em ON p.PROJNO = em.PROJNO
WHERE p.PROJNO LIKE 'IF%'
ORDER BY PROJNO,SORT,EMPLOYEES,START;
-- Exercise 6 Using Subqueries
-- Problem 1
SELECT WORKDEPT,EMPNO,LASTNAME,SALARY
FROM DB2INST1.EMPLOYEE
WHERE SALARY >= ((SELECT AVG(SALARY) FROM DB2INST1.EMPLOYEE)+5000)
ORDER BY WORKDEPT,EMPNO;
-- Problem 2
SELECT EMPNO,LASTNAME
FROM DB2INST1.EMPLOYEE
WHERE EMPNO NOT IN (SELECT EMPNO FROM DB2INST1.EMPPROJACT)
ORDER BY EMPNO;
-- Problem 3
SELECT PROJNO,DAYS(PRENDATE)-DAYS(PRSTDATE) AS DAYS
FROM DB2INST1.PROJECT
WHERE DAYS(PRENDATE)-DAYS(PRSTDATE) LIKE (
    SELECT MIN(DAYS(PRENDATE)-DAYS(PRSTDATE))
    FROM DB2INST1.PROJECT);
-- Problem 4
SELECT * FROM DB2INST1.EMPLOYEE
WHERE WORKDEPT IN (
    SELECT DEPTNO
    FROM DB2INST1.DEPARTMENT
    WHERE DEPTNO NOT IN (
        SELECT WORKDEPT
        FROM (
                 SELECT WORKDEPT, COUNT(SEX)
                 FROM DB2INST1.EMPLOYEE
                 WHERE SEX LIKE 'F'
                 GROUP BY WORKDEPT
             )
    )
);
-- Problem 5
SELECT LASTNAME,
       JOB,
       EDLEVEL,
       YEAR('2000-01-01')-YEAR(HIREDATE) AS YEARS,
       SALARY
FROM DB2INST1.EMPLOYEE
WHERE EDLEVEL = (SELECT EDLEVEL FROM DB2INST1.EMPLOYEE WHERE LASTNAME LIKE 'STERN')
  AND JOB = (SELECT JOB FROM DB2INST1.EMPLOYEE WHERE LASTNAME LIKE 'STERN')
    AND YEAR('2000-01-01')-YEAR(HIREDATE) >=0
ORDER BY SALARY DESC;

-- Exercise 7 Maintaining Data
-- Problem 1
CREATE TABLE STDB262226.TESTEMP(
    EMPNO CHARACTER(6) not null,
    LASTNAME VARCHAR(15) not null,
    WORKDEPT CHARACTER(3) not null,
    HIREDATE DATE not null,
    SALARY DECIMAL(9,2),
    BONUS DECIMAL(9,2),
    primary key(EMPNO)
);
-- Problem 2
INSERT INTO STDB262226.TESTEMP(EMPNO, LASTNAME, WORKDEPT, HIREDATE, SALARY, BONUS)
VALUES  ('000111','SMITH','C01','2000-06-06',25000,0),
        ('000222','BAKER','A00','2000-06-06',28000,null),
        ('000333','THOMAS','D11','2000-06-06',33000,0);
-- Problem 3
INSERT INTO STDB262226.TESTEMP(EMPNO, LASTNAME, WORKDEPT, HIREDATE, SALARY, BONUS)
SELECT EMPNO,LASTNAME,WORKDEPT,HIREDATE,SALARY,BONUS FROM DB2INST1.EMPLOYEE WHERE EMPNO <= '000050';
-- Problem 4
UPDATE STDB262226.TESTEMP SET BONUS = 500 WHERE LASTNAME LIKE 'SMITH';
-- Problem 5
UPDATE STDB262226.TESTEMP SET SALARY = SALARY + 1000 WHERE WORKDEPT LIKE 'C01';
-- Problem 6
DELETE FROM STDB262226.TESTEMP WHERE LASTNAME LIKE 'SMITH';
-- Problem 7
INSERT INTO STDB262226.TESTEMP(EMPNO, LASTNAME, WORKDEPT, HIREDATE, SALARY, BONUS)
SELECT EMPNO,LASTNAME,WORKDEPT,HIREDATE,SALARY,BONUS FROM DB2INST1.EMPLOYEE WHERE EMPNO > '000050';
-- Problem 8
UPDATE STDB262226.TESTEMP SET WORKDEPT = 'E01' WHERE LASTNAME LIKE 'SPENSER';
-- Problem 9
INSERT INTO STDB262226.TESTEMP(EMPNO, LASTNAME, WORKDEPT, HIREDATE, SALARY, BONUS)
VALUES  ('000360','BROWN','D01',current_date ,45000,null);
-- Problem 10
DELETE FROM STDB262226.TESTEMP WHERE 1=1;
DROP TABLE  STDB262226.TESTEMP;
-----------------------------------------------------END----------------------------------------------------------------
-- DAYS STAY IN KMUTT
SELECT DAYS(CURRENT_DATE ) - DAYS('2019-08-13') FROM SYSIBM.SYSDUMMY1;
-- YEAR OLD
SELECT YEAR(DATE(CURRENT_DATE ) - DATE('2001-07-11')) FROM SYSIBM.SYSDUMMY1;
-- 2 MONTHS 20 DAYS AFTER THIS DAY
SELECT CURRENT_DATE + 2 MONTHS  + 20 DAYS FROM SYSIBM.SYSDUMMY1;

SELECT CURRENT_DATE + 5 MONTHS AS PLUS5MONTH,
       CURRENT_DATE + 150 DAYS AS PLUE150DAYS,
       CONCAT(ABS(DAYS(CURRENT_DATE + 5 MONTHS)-DAYS( CURRENT_DATE + 150 DAYS)),' DAYS') AS DAYDIFF
FROM SYSIBM.SYSDUMMY1;

SELECT CURRENT_DATE + 20 MONTHS AS PLUS20MONTH,
       CURRENT_DATE + 1500 DAYS AS PLUE1500DAYS,
       CONCAT(ABS(YEAR((CURRENT_DATE + 20 MONTHS) - (CURRENT_DATE + 1500 DAYS))) ,' YEAR') AS YEAR,
       CONCAT(ABS(MONTH((CURRENT_DATE + 20 MONTHS) - (CURRENT_DATE + 1500 DAYS))) ,' MONTH') AS MONTH,
       CONCAT(ABS(DAY((CURRENT_DATE + 20 MONTHS) - (CURRENT_DATE + 1500 DAYS))) ,' DAY') AS DAY
FROM SYSIBM.SYSDUMMY1;

SELECT 'World population is still increasing' FROM SYSIBM.SYSDUMMY1 WHERE (60*60*24/4) - (619647 / (DAYS(CURRENT_DATE)  - DAYS('2019-12-31'))) > 0
UNION
SELECT 'World population is decreasing' FROM SYSIBM.SYSDUMMY1 WHERE (60*60*24/4) - (619647 / (DAYS(CURRENT_DATE)  - DAYS('2019-12-31'))) < 0 ;
-- AVERAGE SALARY OF EACH DEPARTMENT
SELECT WORKDEPT,decimal(round(AVG(SALARY),2),7,2)
FROM DB2INST1.EMPLOYEE
WHERE SEX = 'F'
GROUP BY WORKDEPT
HAVING AVG(SALARY) > 50000;
-- EXAMPLE
SELECT WORKDEPT,JOB,AVG(SALARY)
FROM DB2INST1.EMPLOYEE
WHERE JOB <> 'MANAGER'
GROUP BY WORKDEPT, JOB
HAVING AVG(SALARY) > 28000
ORDER BY 3 DESC